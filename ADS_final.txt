#include <Wire.h>
#include <EEPROM.h>
#include <Adafruit_ADS1X15.h>

// === ADC Modules ===
Adafruit_ADS1115 ads1;
Adafruit_ADS1115 ads2;
Adafruit_ADS1115 ads3;
Adafruit_ADS1115 ads4;

// === Voltage Divider Constants ===
float R1 = 900000.0;  // 900kŒ©
float R2 = 43500.0;   // 44kŒ©
float voltage_divider_ratio = (R1 + R2) / R2;

// === EEPROM addresses ===
const int EEPROM_START_ADDR = 0; // Starting address for thresholds
const int THRESHOLD_SIZE = 8;    // 4 bytes min + 4 bytes max
const int TOTAL_CELLS = 16;

// === Button and LED pins ===
const int buttonPin = 8;
const int ledPin = 13;

// === Cell Structure ===
struct CellStatus {
  const char* label;
  Adafruit_ADS1115* ads;
  uint8_t channel;
  float minV;
  float maxV;
  bool over;
  bool under;
  float liveV;

  CellStatus(const char* l, Adafruit_ADS1115* a, uint8_t ch)
    : label(l), ads(a), channel(ch), minV(0), maxV(0), over(false), under(false), liveV(0.0f) {}
};

// === Define Cells ===
CellStatus cells[] = {
  // Module 1: 0x48
  CellStatus("A CELL", &ads1, 0),
  CellStatus("B CELL", &ads1, 1),
  CellStatus("C CELL", &ads1, 2),
  CellStatus("D CELL", &ads1, 3),

  // Module 2: 0x49
  CellStatus("E CELL", &ads2, 0),
  CellStatus("F CELL", &ads2, 1),
  CellStatus("G CELL", &ads2, 2),
  CellStatus("H CELL", &ads2, 3),

  // Module 3: 0x4A
  CellStatus("I CELL", &ads3, 0),
  CellStatus("J CELL", &ads3, 1),
  CellStatus("K CELL", &ads3, 2),
  CellStatus("L CELL", &ads3, 3),

  // Module 4: 0x4B
  CellStatus("M CELL", &ads4, 0),
  CellStatus("N CELL", &ads4, 1),
  CellStatus("O CELL", &ads4, 2),
  CellStatus("P CELL", &ads4, 3),
};

const int numCells = sizeof(cells) / sizeof(cells[0]);

// === Setup ===
void setup() {
  Serial.begin(115200);
  pinMode(ledPin, OUTPUT);
  pinMode(buttonPin, INPUT_PULLUP);

  // Init ADS
  if (!ads1.begin(0x48)) { Serial.println("‚ùå ADS1115 #1 not found"); while (1); }
  if (!ads2.begin(0x49)) { Serial.println("‚ùå ADS1115 #2 not found"); while (1); }
  if (!ads3.begin(0x4A)) { Serial.println("‚ùå ADS1115 #3 not found"); while (1); }
  if (!ads4.begin(0x4B)) { Serial.println("‚ùå ADS1115 #4 not found"); while (1); }

  ads1.setGain(GAIN_ONE);  // ¬±4.096V
  ads2.setGain(GAIN_ONE);
  ads3.setGain(GAIN_ONE);
  ads4.setGain(GAIN_ONE);

  // Load thresholds from EEPROM
  loadThresholds();
  Serial.println("‚úÖ Loaded thresholds from EEPROM:");
  printThresholds();
}

// === Main Loop ===
void loop() {
  readSerialUpdateThresholds();

  if (digitalRead(buttonPin) == LOW) {
    Serial.println("üîò Button Pressed. Measuring for 5 seconds...");
    Serial.println("Cycle Start\n");

    unsigned long start = millis();

    for (int i = 0; i < numCells; i++) {
      cells[i].over = false;
      cells[i].under = false;
    }

    while (millis() - start < 5000) {
      for (int i = 0; i < numCells; i++) {
        float v = readVoltage(*cells[i].ads, cells[i].channel);
        cells[i].liveV = v;

        if (v > cells[i].maxV) cells[i].over = true;
        else if (v < cells[i].minV) cells[i].under = true;

        printTimestamp();
        Serial.print(cells[i].label);
        Serial.print(" Voltage: ");
        Serial.print(v, 3);
        Serial.println(" V");

        if (cells[i].over) {
          printTimestamp();
          Serial.print(" ");
          Serial.print(cells[i].label);
          Serial.println(" Overvoltage!");
        } else if (cells[i].under) {
          printTimestamp();
          Serial.print(" ");
          Serial.print(cells[i].label);
          Serial.println(" Undervoltage!");
        }
      }
      Serial.println("--------------------------------------------------");
      delay(500);  // refresh rate
    }

    // Final summary
    bool fault = false;
    Serial.println("\nüìä Final Summary:");
    for (int i = 0; i < numCells; i++) {
      Serial.print(cells[i].label);
      if (cells[i].over) {
        Serial.println(" Overvoltage");
        fault = true;
      } else if (cells[i].under) {
        Serial.println(" Undervoltage");
        fault = true;
      } else {
        Serial.println(" OK");
      }
    }

    digitalWrite(ledPin, fault ? HIGH : LOW);

    Serial.println("Cycle End");
    Serial.println("--------------------------------------------------\n");
    delay(500);
  }
}

// === Read voltage helper ===
float readVoltage(Adafruit_ADS1115& ads, uint8_t channel) {
  int16_t raw = ads.readADC_SingleEnded(channel);
  float v = raw * 0.125 / 1000.0;  // mV to V
  return v * voltage_divider_ratio;
}

// === Timestamp printing ===
void printTimestamp() {
  unsigned long t = millis();
  unsigned long h = (t / (1000UL * 60 * 60)) % 24;
  unsigned long m = (t / (1000UL * 60)) % 60;
  unsigned long s = (t / 1000UL) % 60;
  unsigned long ms = t % 1000;

  if (h < 10) Serial.print("0");
  Serial.print(h); Serial.print(":");

  if (m < 10) Serial.print("0");
  Serial.print(m); Serial.print(":");

  if (s < 10) Serial.print("0");
  Serial.print(s); Serial.print(".");

  if (ms < 100) Serial.print("0");
  if (ms < 10) Serial.print("0");
  Serial.print(ms);
  Serial.print(" -> ");
}

// === EEPROM threshold functions ===
void loadThresholds() {
  for (int i = 0; i < numCells; i++) {
    EEPROM.get(EEPROM_START_ADDR + i * THRESHOLD_SIZE, cells[i].minV);
    EEPROM.get(EEPROM_START_ADDR + i * THRESHOLD_SIZE + 4, cells[i].maxV);
  }
}

void saveThresholds() {
  for (int i = 0; i < numCells; i++) {
    EEPROM.put(EEPROM_START_ADDR + i * THRESHOLD_SIZE, cells[i].minV);
    EEPROM.put(EEPROM_START_ADDR + i * THRESHOLD_SIZE + 4, cells[i].maxV);
  }
}

// === Serial reading function ===
void readSerialUpdateThresholds() {
  if (Serial.available()) {
    String input = Serial.readStringUntil('\n');
    input.trim();

    if (input.length() > 0) {
      // Parse CSV
      int idx = 0;
      int lastComma = -1;
      for (int i = 0; i < numCells; i++) {
        // Min voltage
        int nextComma = input.indexOf(',', lastComma + 1);
        if (nextComma == -1) break;
        cells[i].minV = input.substring(lastComma + 1, nextComma).toFloat();
        lastComma = nextComma;

        // Max voltage
        nextComma = input.indexOf(',', lastComma + 1);
        if (nextComma == -1) break;
        cells[i].maxV = input.substring(lastComma + 1, nextComma).toFloat();
        lastComma = nextComma;
      }

      saveThresholds();
      Serial.println("‚úÖ Thresholds updated via Serial:");
      printThresholds();
    }
  }
}

// === Print thresholds ===
void printThresholds() {
  for (int i = 0; i < numCells; i++) {
    Serial.print(cells[i].label);
    Serial.print(": Min = ");
    Serial.print(cells[i].minV, 3);
    Serial.print(" V, Max = ");
    Serial.print(cells[i].maxV, 3);
    Serial.println(" V");
  }
}
